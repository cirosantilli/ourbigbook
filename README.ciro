\h[1][Cirodown]

A Markup language to write multipage or single page HTML / PDF books that is saner and more powerful than Markdown and Asciidoctor, but still nicer to write than XML and JSON. Reference implementation in JavaScript. No implementation yet.

\toc

\h[2][Design goals]
{id_scope=true}

Cirodown is designed entirely to allow writing complex professional HTML and PDF scientific books, blogs, articles and encyclopedias.

Cirodown aims to be the ultimate LaTeX "killer", allowing books to be finally published as either HTML or PDF painlessly (LaTeX being only a backend to PDF generation), supporting out of the box feature such as:

\l[references to headers, images, etc.]
\l[titles on figures, equations, math, etc.]
\l[KaTeX server side math]
\l[references across input files]
\l[table of contents that crosses input files]

It is meant to be both saner and more powerful than Markdown and Asciidoctor.

The tradeoff for those features is that the language is slightly heavier to read and write.

It is intended that this will be an acceptable downside as Cirodown will be used primarily large complex content such as books rather than forum posts, and will therefore primarily written either:

\l[in text editors locally, where users have more features than in random browser textareas]
\l[in a dedicated website that will revolutionize education, and therefore have a good JavaScript editing interface: \a[https://github.com/cirosantilli/write-free-science-books-to-get-famous-website]]

\h[3][Saner]

To be saner than both Markdown and Asciidoctor, Cirodown has exactly five magic characters, with similar functions as in LaTeX:

\l[\c[\\] backslash to start a macro, like LaTeX]
\l[\c[\{] and \c[\}]: left and right square brackets to delimit optional macro arguments]
\l[\c[\[] and \c[\]]: left and right curly braces bracket to start an optional arguments]

And double blank newlines for \x[paragraphs][paragraphs] if you are pedantic.

We would like to have only square brackets for both optional and mandatory to have even less magic characters, but that would make the language difficult to parse for computer and humans. LaTeX was right for once!

This produces a very regular syntax that is easy to learn, including doing:

\l[arbitrary nesting of elements]
\l[adding arbitrary properties to elements]

This sanity also makes the end tail learning curve of the endless edge cases found in Markdown and Asciidoctor disappear.

The language is designed to be philosophically isomorphic to HTML to:

\l[further reduce the learning curve]
\l[ensure that most of HTML constructs can be reached, including arbitrary nesting]

More precisely:

\l[macro names map to tag names, e.g.: \c[[\a]] to \c[<a]]
\l[
  one of the arguments of macros, maps to the content of the HTML element, and the others map to attributes.

  E.g., in a link:

  \C[[\a[http://example.com][Link text]]]

  the first macro argument:

  \C[http://example.com]

  maps to the \c[href] of \c[<a], and the second macro argument:

  \C[Link text]

  maps to the internal content of \c[<a>Link text<>]
]

\h[3][More powerful]

The \x[saner][high sanity of Cirodown], also makes creating new macro extensions extremely easy and intuitive.

All built-in language features use the exact same API as new extensions, which ensures that the extension API is sane forever.

Markdown is clearly missing many key features such as block attributes and \x[internal-cross-references], and has no standardized extension mechanism.

The "more powerful than Asciidoctor" part is only partially true, since Asciidoctor is very featureful can do basically anything through extensions.

The difference is mostly that Cirodown is completely and entirely focused on making amazing scientific books, and so will have key features for that application out-of-the box.

Another advantage over Asciidoctor is that the reference implementation of Cirodown is in JavaScript, and can therefore be used on browser live preview out of the box. Asciidoctor does Transpile to JS with \a[https://github.com/opal/opal][Opal], but who wants to deal with that layer of complexity?

\h[2][Paragraphs \c[[\p]]]
[paragraphs]

OK, this is too common, so we opted for some insanity here: double newline is a paragraph!

Paragraph 1.

Paragraph 2.

Equivalently however, you can use an explicit \c[[\p]] macros as well, which is required for example to add properties to a paragraph, e.g.:

\p{id=paragraph-1}[Paragraph 1]
\p{id=paragraph-2}[Paragraph 2]

Paragraphs are created automatically inside \x[macro-argument-syntax][macro argument] whenever a double newline appears.

The paragraphs start at the beginning of the parent element of the double newlines, and end at the end of it.

For example:

\C[[
\somemacro[a b c d][c

d

e]
]]

would parse as:

\C[[
\somemacro[a b c][
\p[d]
\p[e]
\p[f]
]
]]

Note how the second argument has had newlines added because it contains

\h[2][Links \c[[\a]]]
[links]

Autolink (link text is the same as the link): \a[http://example.com].

Link with custom text: \a[http://example.com][my custom link text].

\a[http://example.com][Multiple

paragraphs]

\h[2][Internal cross references \c[[\x]]]
[internal-cross-references]

Every macro in Cirodown can have an optional \c[id] and a \c[title] property.

Those that have a \c[title] but no \c[id], get an auto-generated ID from the title: \x[automatic-id-from-title].

For macros that do have an ID, you can write a cross reference to it:

\C[[
\h[2][My title][my-id]

Read this \x[my-id][amazing section].
]]

If the second argument, the \c[content], is not present, it expand to the header title, e.g.:

\C[[
\h[2][My title][my-id]

Read this \x[my-id].
]]

is the same as:

\C[[
\h[2][My title][my-id]

Read this \x[my-id][My title].
]]

To also show the section auto-generated number as in"Section X.Y My title" we add the optional \c{\{style=full\}} param to the cross reference, for example:

\C[[
\h[2][My title][my-id]

Read this \x[my-id]{style=full}.
]]

\h[3][Internal cross file references]

Reference to the first header of another file: \x[not-readme]. That header gets its ID from the file name by default.

Reference to an internal header of another file: \x[not-readme/h2-in-not-the-readme]. By default, That header ID gets prefixed by the ID of the top header.

\h[3][Automatic ID from title]

If a macro has the \c[title] property is present but no explicit \c[id], an ID is created automatically from the \c[title], by applying the following transformations:

\l[convert all of \c[A-Z] characters to lowercase]
\l[convert consecutive sequences of all non \c[a-z0-9] ASCII characters to a single hyphen \c[-]. Note that this leaves non-ASCII character untouched.]
\l[strip leading or trailing hyphens]

Note how those rules leave non ASCII Unicode characters untouched, as capitalization and determining if something "is a letter or not" in those cases can be tricky.

So for example, the following automatic IDs would be generated:

\tr[
  \th[title]
  \th[id]
  \th[comments]
]
\tr[
  \td[My favorite title]
  \td[my-favorite-title]
  \td
]
\tr[
  \td[Ciro's markdown is awesome]
  \td[ciro-s-markdown-is-awesome]
  \td
]
\tr[
  \td[The École Polytechnique]
  \td[the-École-polytechnique]
  \td[We leave the non ASCII uppercase \a[https://en.wikipedia.org/wiki/Acute_accent][acute accented] \c[e], \c[É], untouched by default]
]

\h[2][Headers \c[[\h[1]]], \c[[\h[2]]], etc.]
[headers]

\h[3][Unlimited header levels]

There is no limit to how many levels we can have! HTML is limited to \c[h6], so Cirodown just renders \c[<div class="header">] instead.

\h[4][My h4]

\h[5][My h5]

\h[6][My h6]

\h[7][My h7]

\h[8][My h8]

\h[10][My h9]

\h[10][My h10]

\h[11][My h11]

\h[12][My h12]

\h[13][My h12]

\h[3][Table of contents \c[[\toc]]]
[table-of-contents]

We can add table of contents anywhere in the document, e.g. here is another one:

\toc

Table of contents only include the items which live in child headers relative to the current location.

\h[4][id_scope]

If this header attribute is \c{true}, then the ID of all children are prefixed with the ID of this header + a slash \c{/}.

This property is true by default for cross file references, although it can be turned off explicitly with \c{id-scope=false}.

References withing a single scope do not need the parent scope prefix.

\h[3][Header explicit levels vs nesting design choice]

Arguably, the language would be even saner if we did:

\C[[
\h[My h1][

Paragraph.

\h[My h2][]
]
]]

rather than having explicit levels.

But we chose not to do it like most markups available because it leads to too many nestiing levels, and hard to determine where you are without tooling.

\h[3][Includes \c[[\include]]]
[includes]

The \c[[\include]] macro achieves the following goals:

\l[
  show a single header at multiple locations in the table of contents. This makes the TOC into a full blown graph rather than a tree.

  This can be used to implement a tag entirely within the ToC!
]
\l[
  determine where external files will be placed in \c[--single-page] mode.

  When compiling to HTML, we can choose to either:

  \l[compile as multiple pages: default, includes show on ToC and render as \x[internal-cross-references][internal cross references to headers]]
  \l[compile as a single page: selected with the \c[cirodown --single-page] option]
]

If an external header would be included multiple times in a single output page, the ToC contents are duplicated, but the content itself cannot be because that would lead to ID conflicts and large pages.

Therefore, in this case you are forced to specify which include will actually expand to the \c{canonical} attribute:

\C[[
\include[not-the-readme]{canonical=true}
]]

\h[2][Lists \c[[\l]]]
[lists]

With implicit container:

\l[a]
\l[b]
\l[c]

Equivalent with explicit container:

\ul[
\l[a]
\l[b]
\l[c]
]

The explicit container is required if you want to add properties to the list, e.g. a title and an ID: \x[list-my-id]:

\ul{title=My list title}
{id=list-my-id}
[
\l[a]
\l[b]
\l[c]
]

It is also required if you want ordered lists:

\ol[
\l[first]
\l[second]
\l[third]
]

Nested lists with implicit containers:

\l[
  a

  \l[a1]
  \l[a2]
  \l[a2]
]
\l[b]
\l[c]

List item with a paragraph inside of it:

\l[a]
\l[
  I have

  Multiple paragraphs.

  \l[And]
  \l[also]
  \l[a]
  \l[list]
]
\l[c]

\h[2][Tables \c[[\table]], \c[[\tr]], \c[[\th]] and \c[[\td]]]
[tables]

Similar to lists. Implicit container with optional indentation to improve readability:

\tr[
  \th[Header 1]
  \th[Header 2]
]
\tr[
  \td[1 1]
  \td[1 2]
]
\tr[
  \td[2 1]
  \td[2 2]
]

Explicit container to add further properties: \x[table-my-table].

\table{title=My table title}
{id=table-my-table}
[
\tr[
  \th[Header 1]
  \th[Header 2]
]
\tr[
  \td[1 1]
  \td[1 2]
]
\tr[
  \td[2 1]
  \td[2 2]
]
]

\h[2][Figures \c[[\img]]]
[figures]

See this image \x[image-lotus-flower]:

\img[https://upload.wikimedia.org/wikipedia/commons/thumb/f/f5/Lotus_flower_%28978659%29.jpg/640px-Lotus_flower_%28978659%29.jpg]
{title=A lotus flower}
{id=image-lotus-flower}
{source=https://commons.wikimedia.org/wiki/File:Lotus_flower_(978659).jpg}
{description=
  We can have multiple paragraphs here, just for any other parameter argument.

  I'm not even kidding.
}

\h[2][Code \c[[\c]] and \c[[\C]]]
[code]

Inline code blocks (code blocks that should appear in the middle of a paragraph) are done with lower case \c[c]:

\C[[
My \c[inline] code.
]]

renders to:

\C[[
<p>My <code>inline</code> code.</p>
]]

Code blocks (code blocks that should appear outside of paragraphs in their own lines) are done with capital \c[C]:

\C[[
A paragraph.

\C[
A block
of code
]

Another paragraph.
]]

renders to:

\C[[
<p>A paragraph.</p>
<pre><code>A block
of code</code></pre>
<p>Another paragraph.</p>
]]

If the content of the code block has many characters that you would need to \x[escape-characters][escape], you will often want to use \x[literal-arguments], which work just like the do for any other argument. For example:

\C[[[
A paragraph.

\c[[
And now, some long, long code, with lots
of chars that you would need to escape:
\ [  ] {  }
]]

A paragraph.
]]]

Note that the initial newline is skipped automatically in code blocks, just as for any other element, due to: \x[argument-leading-and-trailing-newline-removal], so you don't have to worry about it.

The capital vs lower case theme is also used in other elements, for example \x[math].

The distinction between inline \c[c] and block \c[C] code blocks is needed because in HTML, \a[https://stackoverflow.com/questions/5371787/can-i-have-a-pre-tag-inside-a-p-tag-in-tumblr/58603596#58603596][\c[pre] cannot go inside \c[p]].

We could have chosen to do some magic to differentiate between them, e.g. checking if the block is the only element in a paragraph, but we decided not to do that to keep the language saner.

\h[2][Math \c[[\m]] and \c[[\M]]]
[math]

Via KaTeX server side, oh yes!

Just like code, but LaTeX math goes in.

My inline \m[[\sqrt[1 + 1]]] is awesome.

Escape the closing bracket with backslash: \m[1 - \[1 + 1\] = -1].

Escape the closing bracket with double open and close: \m[[1 - [1 + 1] = -1]] is awesome.

Display math is done with upper case \c[M]:

\M[[
\sqrt[1 + 1]
\sqrt[1 + 1]
]]

\h[2][Cirodown syntax]

\h[3][Macro argument syntax]

\h[4][Positional vs named arguments]

TODO

\l[
  positional

  Gets prefixed by a key `name=`.

  Must come before the mandatory ones, but the order between the optional ones is arbitrary.
]
\l[
  named

  Not prefixed by keys.

  Must always be present, and must come after the optional ones.

  Mandatory arguments can however be empty which is indicated by an empty pair of square brackets:

  \c[\{\]]

  Macros can process this empty value magically or not as documented on their API.

  For example, \x[links] have two mandatory arguments: the URL and text, and the link API treats an empty text as a copy of the URL, which is a common use case:

  \c[[
  \a[http://example.com]
  ]]
]

\h[4][JavaScript interface for arguments]

The JavaScript interface sees arguments as follows:

\c[
function macro_name(args)
]

where args is a dict such that:

\l[optional arguments have the key / value pairs explicitly given on the call]
\l[
  mandatory arguments have a key documented by the API, and the value on the call.

  For example, the link API names its arguments \c[href] and \c[text].
]

\h[4][Newlines between arguments]

The macro name and the first argument, and two consecutive arguments, can be optionally separated by exactly one newline character, e.g.:

\c[[
\h[2]
{id-scope=true}
[Design goals]
]]

is equivalent to:

\c[[
\h[2]{id-scope=true}[Design goals]
]]

and this non-recommended mixed style:

\c[[
\h[2]{id-scope=true}
[Design goals]
]]

This allows to greatly improve the readability of long argument lists by having them one per line.

\h[4][Literal arguments]
[literal]

TODO

\h[5][Escape characters]

For non-literal macro arguments, the rule is simple, you must escape all of:

\l[\c[\\]]
\l[\c[\{]]
\l[\c[\]]]

For literal macro arguments there are two choices.

For longer arguments, especially multiline, the best approach is usually to use the following heredoc-like syntax.

By opening a macro argument with multiple square brackets \c[\{], only the same number of square brackets will be used for closing that opening.

For example, a multiline code block with double open and double close square brackets can be enclosed in triple square brackets:

\c[[[
A line.
[[
Another one.
]]
And another one.
]]]

The same works for inline code: \c[[Cirodown links look like this: \c[http://example.com][Example.]]].

Within literal blocks, you only need to escape constructs that would lead to ambiguity on where the block ends, namely:

\l[
  if a literal starts with open square brackets \c[\[]], then that must be escaped, otherwise it will get interpreted as a heredoc, e.g.:

  \c[[
  \c[\[ This code block starts with a literal open square bracket]
  ]]

  Note that this only ever happens for arguments that don't start with a newline considering \x[Argument leading and trailing newline removal].
]
\l[
  if a literal block ends

  \c[\c[\]]
]

\c[\[ first char was an open brace]

\h[4][Argument leading and trailing newline removal]

If the very first, or very last character of an argument is a newline, then that character is ignored.

For example:

\c[[
\c[
a

b
]
]]

generates something like:

\c[
<pre><code>a

b</code></pre>
]

instead of:

\c[
<pre><code>
a

b
</code></pre>
]

This is extremely convenient to improve the readability of code blocks and similar constructs.

If you absolutely need an opening newline, just add a second leading or trailing newline to the macro argument, e.g.:

\c[[
\c[

a

b

]
]]

\h[4][Argument automatic indentation removal]

Inside of a non-literal block, the very first non-whitespace character determines the indentation level of the content.

This allows seamlessly indenting complex nested content to make it more readable.

For example, a list with complex content could be written without indentation as:

\c[[
\l[a]
\l[
b

\c[[
And now some code
]]

And a paragraph.
]
\l[c]
]]

but it would be more readable as the equivalent:

\c[[
\l[a]
\l[
  b

  \c[[
  And now some code
  ]]

  And a paragraph.
]
\l[c]
]]

If a something tries to reduce the current indentation level, then that leads to an error:

\c[[
\l[a]
\l[
  b

I'm bad because I have negative indentation.

  Back to good.
]
\l[c]
]]

\h[2][Tooling]

\h[3][Multifile and server]

In addition to being a single input single output file conversion tool, our implementation will completely overtake the functions currently done by of Jekyll or other static website generators.

We believe that this is the only way to achieve a perfect unified development experience.

Firstly, the same executable that does single file conversion, when pointed to a directory enter a multi-file mode that does the desired multi-file conversion, resolving for example \x[cross-file-references].

Furthermore, the exact same executable will have a server mode speed up interactive development with a off-the-shelf text editor (as opposed to a \x[editor-and-preview][the planned dedicated editor]).

\h[3][Server and dependency resolution]

TODO xref dep resolution, on demand rebuild

\h[3][Editor and preview]

We must achieve an editor setup with synchronized live side-by-side preview.

It would be amazing to have a WebKit interface that works both on browser for the and locally.

TODO

\h[3][Macro dump]

The compiler executable will have a \c[--dump-macros] option that will dump all macros, describing all of their arguments and including help strings registered by the macro definition API.

\h[3][Test system]

Run all tests:

\c[[
npm test
]]

List all tests:

\c[[
node node_modules/mocha-list-tests/mocha-list-tests.js main.js
]]

As per: \a[https://stackoverflow.com/questions/41380137/list-all-mocha-tests-without-executing-them/58573986#58573986].

Run just one test by name:

\c[[
npm test -- 'one paragraph'
]]

As per: https://stackoverflow.com/questions/10832031/how-to-run-a-single-test-with-mocha TODO: what if the test name is a substring?

\h[3][Internals API]

Tokenized token stream and AST can be obtained as JSON from the API.

Errors can be obtained as JSON from the API.

Everything that you need to write Cirodown tooling, is present in the main API.

All tooling will be merged into one singl repo.

\h[3][The \c[[\toplevel]] implicit macro]
[topelevel]

Every Cirodown document is implicitly put inside a \c[[\toplevel]] document and:

\l[any optionally given arguments at the very beginning of the document will be treated as arguments of the \c[[\toplevel]] macro]
\l[anything else will be put inside the \c[content] argument of the \c[[\toplevel]] macro]

E.g., a Cirodown document that contains:

\c[[
[title=My favorite title]

And now, some content!
]]

is morally equivalent to:

\c[[
\toplevel
[title=My favorite title]
[
And now, some content!
]
]]

In terms of HTML, the `\toplevel` element corresponds to the `<html>`, `<head>`, `<header>` and `<footer>` elements of a document.

\h[3][Formal grammar]

TODO. Describe Cirodown's formal grammar, and classify it in the grammar hierarchy and parsing complexity.

\h[3][TODO]

\l[HTML escapes]
\l[named arguments]
\l[math]
\l[LaTeX output]
\l[output argument description with some CLI help flag]
\l[pass CLIs to test command to enable token and ast logging]

\h[3][Related projects]

\l[\a[https://github.com/rstudio/bookdown], \a[https://bookdown.org/]]. Very similar feature set to what we want!!! Transpiles to markdown, and then goes through Pandoc: https://bookdown.org/yihui/bookdown/pandoc.html[], thus will never run on browser without huge translation layers. But does have an obscene ammount of output formats however.
