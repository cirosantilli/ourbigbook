#!/usr/bin/env node

const assert = require('assert');
const util = require('util');

const cirodown = require('./cirodown')

const convert_opts = {
  body_only: true,
  //show_ast: true,
  //show_parse: true,
  //show_tokens: true,
  //show_tokenize: true,
};

const assert_convert = function(input_string, expected_output) {
  let extra_returns = {fail: false};
  let output = cirodown.convert(input_string, convert_opts, extra_returns);
  if (output !== expected_output || extra_returns.errors.length !== 0) {
    console.error('tokens:');
    console.error(JSON.stringify(extra_returns.tokens, null, 2));
    console.error();
    console.error('ast:');
    console.error(JSON.stringify(extra_returns.ast, null, 2));
    console.error();
    for (const error of extra_returns.errors) {
      console.error(error.toString());
    }
    console.error('input ' + util.inspect(input_string));
    console.error('output ' + util.inspect(output));
    console.error('expect ' + util.inspect(expected_output));
    assert.strictEqual(output, expected_output);
    assert.strictEqual(extra_returns.errors.length, 0);
  }
}

const assert_error = function(input_string, line, column) {
  let extra_returns = {fail: false};
  let output = cirodown.convert(input_string, convert_opts, extra_returns);
  assert.ok(extra_returns.errors.length >= 1);
  let error = extra_returns.errors[0];
  assert.strictEqual(error.line, line);
  assert.strictEqual(error.column, column);
}

// Paragraphs.
it('one paragraph', ()=>{assert_convert('\\p[ab]\n', '<p>ab</p>\n');});
it('two paragraphs', ()=>{assert_convert('p1\n\np2\n', '<p>p1</p>\n<p>p2</p>\n');});
it('three paragraphs', ()=>{assert_convert('p1\n\np2\n\np3\n', '<p>p1</p>\n<p>p2</p>\n<p>p3</p>\n');});

// Escapes.
it('escape backslash',            ()=>{assert_convert('a\\\\b\n', 'a\\b\n')});
it('escape left square bracket',  ()=>{assert_convert('a\\[b\n',  'a[b\n')});
it('escape right square bracket', ()=>{assert_convert('a\\]b\n',  'a]b\n')});
it('escape left curly brace',     ()=>{assert_convert('a\\{b\n',  'a{b\n')});
it('escape right curly brace',    ()=>{assert_convert('a\\}b\n',  'a}b\n')});

// HTML Escapes.
it('html escapes', ()=>{assert_convert(
  '\\a[ab&<>"\'cd][ef&<>"\'gh]\n',
  '<a href="ab&amp;&lt;&gt;&quot;&#039;cd">ef&amp;&lt;&gt;"\'gh</a>\n'
)});

// Positional arguments.
it('p with no content argument', ()=>{assert_convert('\\p\n', '<p></p>\n')});
it('p with empty content argument', ()=>{assert_convert('\\p[]\n', '<p></p>\n')});

// Named arguments.
it('p with id before', ()=>{assert_convert('\\p{id=ab}[cd]\n', '<p id="ab">cd</p>\n')});
it('p with id after', ()=>{assert_convert('\\p[cd]{id=ab}\n', '<p id="ab">cd</p>\n')});

// Literal arguments.
it('literal argument code inline', ()=>{assert_convert('\\c[[\\ab[cd]{ef}]]\n', '<code>\\ab[cd]{ef}</code>\n')});
it('literal argument code block', ()=>{assert_convert(
  `a

\\C[[
\\[]{}
\\[]{}
]]

d
`,
  `<p>a</p>
<pre><code>\\[]{}
\\[]{}
</code></pre>
<p>d</p>
`
)});

// Links.
it('link simple', ()=>{assert_convert(
  'a \\a[http://example.com][example link] b\n',
  'a <a href="http://example.com">example link</a> b\n'
)});
it('link auto', ()=>{assert_convert(
  'a \\a[http://example.com] b\n',
  'a <a href="http://example.com">http://example.com</a> b\n'
)});
it('link with multiple paragraphs', ()=>{assert_convert(
  '\\a[http://example.com][Multiple\n\nparagraphs]\n',
  '<a href="http://example.com"><p>Multiple</p>\n<p>paragraphs</p>\n</a>\n'
)});

// Headers.
it('header simple', ()=>{assert_convert(
  '\\h[1][My header]\n',
  '<h1 id="my-header">My header</h1>\n'
)});
it('header and implicit paragraphs', ()=>{assert_convert(
  `\\h[1][My header 1]

My paragraph 1.

\\h[2][My header 2]

My paragraph 2.
`,
  `<h1 id="my-header-1">My header 1</h1>
<p>My paragraph 1.</p>
<h2 id="my-header-2">My header 2</h2>
<p>My paragraph 2.</p>
`
)});

// Code.
it('code inline', ()=>{assert_convert(
  'a \\c[b c] d\n',
  'a <code>b c</code> d\n'
)});
it('code block', ()=>{assert_convert(
  `a

\\C[
b
c
]

d
`,
  `<p>a</p>
<pre><code>b
c
</code></pre>
<p>d</p>
`
)});

// Errors. Check that they return gracefully with the error line number,
// rather than blowing up an exception.
// TODO
it('unknown macro', ()=>{assert_error('\\reserved_undefined', 1, 2)});
it('too many positional arguments', ()=>{assert_error('\\p[ab][cd]', 1, 7)});
it('unknown named macro argument', ()=>{assert_error('\\c{reserved_undefined=abc}[]', 1, 4)});
it('named argument without =', ()=>{assert_error('\\p{id ab}[cd]', 1, 6)});
