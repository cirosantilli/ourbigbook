#!/usr/bin/env node

const assert = require('assert');
const util = require('util');

const cirodown = require('./cirodown')

const assert_convert = function(input_string, expected_output) {
  let extra_returns = {fail: false};
  let output = cirodown.convert(
    input_string,
    {
      body_only: true,
      //show_ast: true,
      //show_tokens: true,
      //show_parse: true,
    },
    extra_returns
  );
  if (output !== expected_output || extra_returns.errors.length !== 0) {
    console.error('tokens:');
    console.error(JSON.stringify(extra_returns.tokens, null, 2));
    console.error();
    console.error('ast:');
    console.error(JSON.stringify(extra_returns.ast, null, 2));
    console.error();
    for (const error of extra_returns.errors) {
      console.error(error.toString());
    }
    console.error('input ' + util.inspect(input_string));
    console.error('output ' + util.inspect(output));
    console.error('expect ' + util.inspect(expected_output));
    assert.strictEqual(output, expected_output);
    assert.strictEqual(extra_returns.errors.length, 0);
  }
}

// Paragraphs.
it('one paragraph', ()=>{assert_convert('\\p[ab]\n', '<p>ab</p>\n');});
it('two paragraphs', ()=>{assert_convert('p1\n\np2\n', '<p>p1</p>\n<p>p2</p>\n');});
it('three paragraphs', ()=>{assert_convert('p1\n\np2\n\np3\n', '<p>p1</p>\n<p>p2</p>\n<p>p3</p>\n');});

// Escapes.
it('escape backslash',            ()=>{assert_convert('a\\\\b\n', 'a\\b\n')});
it('escape left square bracket',  ()=>{assert_convert('a\\[b\n',  'a[b\n')});
it('escape right square bracket', ()=>{assert_convert('a\\]b\n',  'a]b\n')});
it('escape left curly brace',     ()=>{assert_convert('a\\{b\n',  'a{b\n')});
it('escape right curly brace',    ()=>{assert_convert('a\\}b\n',  'a}b\n')});

// Literal arguments.
it('literal argument code inline', ()=>{assert_convert('\\c[[\\ab[cd]{ef}]]\n', '<code>\\ab[cd]{ef}</code>\n')});
it('literal argument code block', ()=>{assert_convert(
  `a

\\C[[
\\[]{}
\\[]{}
]]

d
`,
  `<p>a</p>
<pre><code>\\[]{}
\\[]{}
</code></pre>
<p>d</p>
`
)});

// Links.
it('link', ()=>{assert_convert(
  'a \\a[http://example.com][example link] b\n',
  'a <a href="http://example.com">example link</a> b\n'
)});
it('link auto', ()=>{assert_convert(
  'a \\a[http://example.com] b\n',
  'a <a href="http://example.com">http://example.com</a> b\n'
)});
it('link with multiple paragraphs', ()=>{assert_convert(
  '\\a[http://example.com][Multiple\n\nparagraphs]\n',
  '<a href="http://example.com"><p>Multiple</p>\n<p>paragraphs</p>\n</a>\n'
)});

// Headers.
it('header', ()=>{assert_convert(
  '\\h[1][My header]\n',
  '<h1 id="my-header">My header</h1>\n'
)});
it('header and implicit paragraphs', ()=>{assert_convert(
  `\\h[1][My header 1]

My paragraph 1.

\\h[2][My header 2]

My paragraph 2.
`,
  `<h1 id="my-header-1">My header 1</h1>
<p>My paragraph 1.</p>
<h2 id="my-header-2">My header 2</h2>
<p>My paragraph 2.</p>
`
)});

// Code..
it('code inline', ()=>{assert_convert(
  'a \\c[b c] d\n',
  'a <code>b c</code> d\n'
)});
it('code block', ()=>{assert_convert(
  `a

\\C[
b
c
]

d
`,
  `<p>a</p>
<pre><code>b
c
</code></pre>
<p>d</p>
`
)});

// Errors. Check that they return gracefully
// rather than blowing up an exception.
// TODO
//it('unknown macro', ()=>{assert_error('\\reserved_undefined')}
//it('unknown macro argument', ()=>{assert_convert('\\c{reserved_undefined=abc}')}
