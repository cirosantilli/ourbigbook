#!/usr/bin/env node

const child_process = require('child_process');
const fs = require('fs');
const path = require('path');

const cirodown = require('cirodown');
const chokidar = require('chokidar');
const commander = require('commander');
const git_url_parse = require("git-url-parse");

const DEFAULT_IGNORE_BASENAMES = [
  '.git',
  'node_modules',
  'out',
];
const DEFAULT_IGNORE_BASENAMES_SET = new Set(DEFAULT_IGNORE_BASENAMES);
const ENCODING = 'utf8';
const IO_RENAME_MAP = {
  README: 'index',
}

/** Report an error with the CLI usage and exit in error. */
function cli_error(message) {
  console.error(`error: ${message}`);
  process.exit(1);
}

function cmd_get_stdout(cmd, args=[], options={}) {
  if (!('dry_run' in options)) {
    options.dry_run = false;
  }
  let out;
  const cmd_str = ([cmd].concat(args)).join(' ');
  console.log(cmd_str);
  if (!options.dry_run) {
    out = child_process.spawnSync(cmd, args);
  }
  let ret;
  if (options.dry_run) {
    ret = '';
  } else {
    if (out.status != 0) {
      throw `cmd: \n${cmd_str}\nstdout: ${out.stdout.toString(ENCODING)}\nstderr: ${out.stderr.toString(ENCODING)}\n`;
    }
    ret = out.stdout.toString(ENCODING);
  }
  return ret;
}

/** Convert input from a string to output and return the output as a string.
 *
 * Wraps cirodown.convert with CLI usage convenience.
 *
 * @param {String} input
 * @return {String}
 */
function convert_input(input, options, convert_input_options={}) {
  const new_options = Object.assign({}, options);
  if ('title' in convert_input_options) {
    new_options.title = convert_input_options.title;
  }
  new_options.extra_returns = {};
  let output = cirodown.convert(input, new_options, new_options.extra_returns);
  if (convert_input_options.cli_options.showTokens) {
    console.error('tokens:');
    console.error(JSON.stringify(new_options.extra_returns.tokens, null, 2));
    console.error();
  }
  if (convert_input_options.cli_options.showAst) {
    console.error('ast:');
    console.error(JSON.stringify(new_options.extra_returns.ast, null, 2));
    console.error();
  }
  for (const error of new_options.extra_returns.errors) {
    console.error(error.toString(convert_input_options.input_path));
  }
  if (convert_input_options.cli_options.watch) {
    console.log();
  }
  if (new_options.extra_returns.errors.length > 0) {
    convert_input_options.had_error = true;
  }
  return output;
}

/** Convert .ciro to output format and save it to a file instead of returning as a string.
 *
 * The output file name is derived from the input file name with the output extension.
 */
function convert_path_to_file(input_path, options, convert_input_options={}) {
  let input_path_parse = path.parse(input_path);
  if (input_path_parse.ext === '.ciro') {
    let output = convert_path(input_path, options, convert_input_options);
    let name = input_path_parse.name;
    if (input_path_parse.name in IO_RENAME_MAP) {
      name = IO_RENAME_MAP[name];
    }
    let output_path = path.join(input_path_parse.dir, name) + '.html';
    if (convert_input_options.cli_options.outdir) {
      fs.mkdirSync(convert_input_options.cli_options.outdir, {recursive: true});
      output_path = path.join(convert_input_options.cli_options.outdir, output_path);
    }
    fs.writeFileSync(output_path, output);
  }
}

/** Convert input from a path to output and return the output as a string.
 *
 * @return {String}
 */
function convert_path(input_path, options, convert_input_options) {
  if (!('multifile' in convert_input_options)) {
    convert_input_options.multifile = false;
  }
  let new_convert_input_options = Object.assign({}, convert_input_options);
  if (convert_input_options.multifile) {
    new_convert_input_options.input_path = input_path;
  }
  let input = fs.readFileSync(input_path, new_convert_input_options.encoding);
  let output = convert_input(input, options, new_convert_input_options);
  if (new_convert_input_options.had_error) {
    convert_input_options.had_error = true;
  }
  return output;
}

/** https://stackoverflow.com/questions/5827612/node-js-fs-readdir-recursive-directory-search
 *
 * @param {Set} skip_basenames
 */
function* walk_files_recursively(file_or_dir, skip_basenames) {
  if (fs.lstatSync(file_or_dir).isDirectory()) {
    const dirents = fs.readdirSync(file_or_dir, {withFileTypes: true});
    for (const dirent of dirents) {
      if (!skip_basenames.has(dirent.name)) {
        const res = dirent.name;
        if (dirent.isDirectory()) {
          yield* walk_files_recursively(res, skip_basenames);
        } else {
          yield res;
        }
      }
    }
  } else {
    yield file_or_dir;
  }
}

// CLI options.
commander.option('--body-only', 'output only the content inside the HTLM body element', false);
commander.option('--dry-run', "don't run most external commands, see: https://github.com/cirosantilli/linux-kernel-module-cheat/tree/6d0a900f4c3c15e65d850f9d29d63315a6f976bf#dry-run-to-get-commands-for-your-project", false);
commander.option('--help-macros', 'print the metadata of all macros to stdout in JSON format. https://cirosantilli.com/cirodown/#', false);
commander.option('--html-embed', 'TODO embed all external resources like images and linked CSS into a single HTML file', false);
commander.option('--outdir <outdir>', 'if the output would be saved to a file e.g. when building a directory, use this directory as the root');
commander.option('--output-format', 'output format');
commander.option('--publish', "http://cirosantilli.com/cirodown#publish");
commander.option('--publish-commit <commit-message>', "http://cirosantilli.com/cirodown#publish-commit");
commander.option('--show-ast', 'print the AST to stderr');
commander.option(
  '--show-ast-inside',
  'print the AST to stderr from inside convert before it returns. ' +
    'Useful to debug the program if conversion blow up on the next stages.'
);
commander.option('--show-parse', 'print parsing internals to stderr');
commander.option('--show-tokenize', 'print tokenization internals to stderr');
commander.option('--show-tokens', 'print the token stream to stderr');
commander.option(
  '--show-tokens-inside',
  'print the token stream to stderr from inside convert before it returns. ' +
    'Useful to debug the program if conversion blow up on the next stages. ' +
    'Also adds token index to the output, which makes debugging the parser ' +
    'way easier.'
);
commander.option('--watch', 'http://cirosantilli.com/cirodown#watch');
let inputPath;
commander.arguments(
  '[input_path]',
  undefined,
  'http://cirosantilli.com/cirodown#cirodown-executable',
).action(function (input_path) {
  inputPath = input_path;
});
commander.parse(process.argv);

// Action.
if (commander.helpMacros) {
  console.log(JSON.stringify(macro_list_to_macros(), null, 2));
} else {
  let input;
  let title;
  let output;
  let options = {
    body_only: commander.bodyOnly,
    show_ast: commander.showAstInside,
    show_parse: commander.showParse,
    show_tokens: commander.showTokensInside,
    show_tokenize: commander.showTokenize,
  };
  let convert_input_options = {
    cli_options: commander,
    encoding: ENCODING,
    had_error: false,
    multifile: true,
  };
  let publish = commander.publish || commander.publishCommit !== undefined;
  if (inputPath === undefined) {
    if (publish) {
      cli_error('--publish is incompatible with input from stdin');
    }
    if (commander.watch) {
      cli_error('--watch is incompatible with input from stdin');
    }
    title = 'stdin';
    input = fs.readFileSync(0, ENCODING);
    convert_input_options.multifile = false;
    output = convert_input(input, options, convert_input_options);
  } else {
    if (!fs.existsSync(inputPath)) {
      cli_error(`input_path does not exist: "${inputPath}"`);
    }
    if (commander.watch) {
      if (publish) {
        cli_error('--publish and --watch are incompatible');
      }
      let watcher = chokidar.watch(inputPath, {ignored: DEFAULT_IGNORE_BASENAMES});
      watcher.on('change', function(path) {
        convert_path_to_file(path, options, convert_input_options);
      }).on('add',  function(path) {
        convert_path_to_file(path, options, convert_input_options);
      });
    } else {
      if (fs.lstatSync(inputPath).isFile()) {
        if (publish) {
          cli_error('--publish must take a directory as input, not a file');
        }
        convert_input_options.multifile = false;
        output = convert_path(inputPath, options, convert_input_options);
      } else {
        let actual_input;
        let publish_branch;
        let publish_dir = path.join(inputPath, 'out', 'publish');
        let remote_url;
        let src_branch;
        let cmd_options = {
          dry_run: commander.dryRun,
        }

        // Clone the source to ensure that only git tracked changes get built and published.
        if (publish) {
          if (!fs.existsSync(path.join(inputPath, '.git'))) {
            cli_error('--publish must point to the root of a git repository');
          }
          remote_url = cmd_get_stdout('git', ['-C', inputPath, 'config', '--get', 'remote.origin.url'], cmd_options).slice(0, -1);
          src_branch = cmd_get_stdout('git', ['-C', inputPath, 'rev-parse', '--abbrev-ref', 'HEAD'], cmd_options).slice(0, -1);
          if (commander.dryRun) {
            remote_url = 'git@github.com:cirosantilli/cirodown.git';
            src_branch = 'master';
          }
          const parsed_remote_url = git_url_parse(remote_url);
          if (parsed_remote_url.source !== 'github.com') {
            cli_error('only know how  to publish to origin == github.com currently, please send a patch');
          }
          let remote_url_path_components = parsed_remote_url.pathname.split(path.sep);
          if (remote_url_path_components[2].startsWith(remote_url_path_components[1] + '.github.io')) {
            publish_branch = 'master';
          } else {
            publish_branch = 'gh-pages';
          }
          if (src_branch === publish_branch) {
            cli_error(`source and publish branches are the same: ${publish_branch}`);
          }
          fs.mkdirSync(publish_dir, {recursive: true});
          if (commander.publishCommit !== undefined) {
            cmd_get_stdout('git', ['-C', inputPath, 'add', '-u'], cmd_options);
            cmd_get_stdout('git', ['-C', inputPath, 'commit', '-m', commander.publishCommit], cmd_options);
          }
          if (!fs.existsSync(path.join(publish_dir, '.git'))) {
            cmd_get_stdout('git', ['clone', '--recursive', inputPath, publish_dir], cmd_options);
          } else {
            cmd_get_stdout('git', ['-C', publish_dir, 'checkout', '--', '.'], cmd_options);
            cmd_get_stdout('git', ['-C', publish_dir, 'clean', '-x', '-d', '-f'], cmd_options);
            cmd_get_stdout('git', ['-C', publish_dir, 'pull'], cmd_options);
            cmd_get_stdout('git', ['-C', publish_dir, 'submodule', 'update', '--init'], cmd_options);
          }

          // Set some variables especially for publishing.
          actual_input = publish_dir;
          commander.outdir = path.join(publish_dir, 'out', 'publish');
        } else {
          actual_input = inputPath;
        }

        // Do the actual conversion.
        for (const path of walk_files_recursively(actual_input, DEFAULT_IGNORE_BASENAMES_SET)) {
          convert_path_to_file(path, options, convert_input_options);
        }

        // Publish the converted output if build succeeded.
        if (publish && !convert_input_options.had_error) {
          // Push the original source.
          cmd_get_stdout('git', ['-C', inputPath, 'push'], cmd_options);
          if (!fs.existsSync(path.join(commander.outdir, '.git'))) {
            cmd_get_stdout('git', ['-C', commander.outdir, 'init'], cmd_options);
            if (publish_branch !== 'master') {
              // https://stackoverflow.com/questions/42871542/how-to-create-a-git-repository-with-the-default-branch-name-other-than-master
              cmd_get_stdout('git', ['-C', commander.outdir, 'checkout', '-b', publish_branch], cmd_options);
            }
            cmd_get_stdout('git', ['-C', commander.outdir, 'remote', 'add', 'origin', remote_url], cmd_options);
            cmd_get_stdout('git', ['-C', commander.outdir, 'fetch', 'origin'], cmd_options);
            cmd_get_stdout('git', ['-C', commander.outdir, 'reset', `origin/${publish_branch}`], cmd_options);
          }
          gemfile_content = "gem 'github-pages', group: :jekyll_plugins\n";
          if (!commander.dryRun) {
            fs.writeFileSync(path.join(commander.outdir, 'Gemfile'), gemfile_content);
          }
          cmd_get_stdout('git', ['-C', commander.outdir, 'add', '.'], cmd_options);
          source_commit = cmd_get_stdout('git', ['-C', inputPath, 'log', '-n1', '--pretty=%H', src_branch], cmd_options).slice(0, -1);
          if (commander.dryRun) {
            source_commit = '0000111122223333444455556666777788889999';
          }
          cmd_get_stdout('git', ['-C', commander.outdir, 'commit', '-m', source_commit], cmd_options);
          cmd_get_stdout('git', ['-C', commander.outdir, 'push', 'origin', `${publish_branch}:${publish_branch}`], cmd_options);
        }
      }
    }
  }
  if (output !== undefined) {
    console.log(output);
  }
  if (!commander.watch) {
    process.exit(convert_input_options.had_error);
  }
}
