#!/usr/bin/env node

const fs = require('fs');
const util = require('util');

// https://stackoverflow.com/questions/44447847/enums-in-javascript-with-es6/49709701#49709701
const make_enum = function(arr) {
  let obj = {};
  for (let val of arr){
    obj[val] = Symbol(val);
  }
  return Object.freeze(obj);
}

const AstNode = class {
  /**
   * @param {String} type - plaintext or macro
   * @param {Object[String, Array[AstNode]|String} arguments
   *        If type is macro, the Object with child arguments.
   *        Otherwise, it ype is text, , the raw String.
   */
  constructor(macro_name, args, line, column) {
    this.macro_name = macro_name;
    this.args = args;
    this.line = line;
    this.column = column;
  }

  convert(options) {
    let macro = macros[this.macro_name];
    return macro.convert(this.args, options);
  }
}

const TokenType = make_enum([
  'PLAINTEXT',
  'MACRO_NAME',
  'POSITIONAL_ARGUMENT_START',
  'POSITIONAL_ARGUMENT_END',
  'NAMED_ARGUMENT_START',
  'NAMED_ARGUMENT_END',
]);

const Token = class {
  /**
   * @param {String} type
   * @param {String} value - Default: undefined
   * @param {number} line
   * @param {number} column
   */
  constructor(type, line, column, value) {
    this.type = type;
    this.line = line;
    this.column = column;
    this.value = value;
  }

  toJSON() {
    return {
      type:         this.type.toString(),
      line:   this.line,
      column: this.column,
      value:        this.value
    }
  }
}

const Argument = class {
  /**
   * @param {String} name
   */
  constructor(options) {
    this.name = options.name;
  }
}

const Macro = class {
  /**
   * @param {Array[Argument]} args
   * @param {Function} convert
   */
  constructor(args, convert) {
    this.args = args;
    this.convert = convert;
    this.name_to_arg = {};
    this.index_to_arg = {};
    let i = 0;
    for (const arg of args) {
      let name = arg.name;
      if (name in this.name_to_arg) {
        throw new Error('name already taken: ' + name);
      }
      this.name_to_arg[name] = arg;
      this.index_to_arg[i] = arg;
      i += 1;
    }
  }
}

const convert_arg = function(arg) {
  let converted_arg = '';
  for (const macro of arg) {
    converted_arg += macro.convert()
  }
  return converted_arg;
}

let macros = {
  p: new Macro(
    [
      new Argument({
        name: 'content',
      }),
    ],
    function(args, options) {
      return `<p>${convert_arg(args.content)}</p>\n`
    }
  ),
  a: new Macro(
    [
      new Argument({
        name: 'href',
      }),
      new Argument({
        name: 'content',
      }),
    ],
    function(args, options) {
      return `<a href="${convert_arg(args.href)}">${convert_arg(args.content)}</p>`
    }
  ),
  plaintext: new Macro(
    [
      new Argument({
        name: 'content',
      }),
    ],
    function(args, options) {
      return args;
    }
  ),
  toplevel: new Macro(
    [
      new Argument({
        name: 'content',
      }),
      new Argument({
        name: 'title',
      }),
    ],
    function(args, options) {
      if (!'title' in args) {
        if ('title' in options) {
          title = options['title'];
        } else {
          title = IN_OUTPUT_ERROR_PREFIX + 'missing title';
          if (!options.body_only) {
            report_error_noline('HTML requires a non-empty title');
            // TODO report error with exit status.
          }
        }
        args.title = new AstNode('plaintext', title);
      }
      let ret = '';
      if (!options.body_only) {
        ret += `<!doctype html>
<html lang=en>
<head>
<meta charset=utf-8>
<title>${convert_arg(args.title)}</title>
<body>
`
      }
      ret += convert_arg(args.content);
      if (!options.body_only) {
        ret += `</body>
</html>
`
      }
      return ret;
    }
  ),
}

const IN_OUTPUT_ERROR_PREFIX = 'CIRODOWN_ERROR: ';
const ESCAPE_CHAR = '\\';
const START_POSITIONAL_ARGUMENT_CHAR = '{';
const END_POSITIONAL_ARGUMENT_CHAR = '}';
const START_NAMED_ARGUMENT_CHAR = '[';
const END_NAMED_ARGUMENT_CHAR = ']';
const ESCAPABLE_CHARS = new Set([
  ESCAPE_CHAR,
  START_POSITIONAL_ARGUMENT_CHAR,
  END_POSITIONAL_ARGUMENT_CHAR,
  START_NAMED_ARGUMENT_CHAR,
  END_NAMED_ARGUMENT_CHAR,
]);

const char_is_alphanumeric = function(c) {
  let code = c.codePointAt(0);
  return (
    // 0-9
    (code > 47 && code < 58) ||
    // A-Z
    (code > 64 && code < 91) ||
    // a-z
    (code > 96 && code < 123)
  )
}

// Valid macro name characters.
const char_is_macro = function (c) {
  return char_is_alphanumeric(c) || c === '_';
};
char_is_macro.chars = new Set(['-', '_']);

const closing_token = function(token) {
  if (token === TokenType.POSITIONAL_ARGUMENT_START)
    return TokenType.POSITIONAL_ARGUMENT_END;
  if (token === TokenType.NAMED_ARGUMENT_START)
    return TokenType.NAMED_ARGUMENT_END;
  return undefined;
}

const report_error = function(line, column, message) {
  report_error_noline(`line ${line} column ${column}: ${message}`);
}

const report_error_noline = function(message) {
  console.error(`error: ${message}`);
}

/**
 * @param {String} input_string
 * @returns {Array[Token]}
 */
const tokenize = function(input_string, extra_returns={}) {
  // https://stackoverflow.com/questions/21397316/split-javascript-string-into-array-of-codepoints-taking-into-account-surrogat/42596897#42596897
  let chars = Array.from(input_string);
  let tokens = [];
  let i = -1;
  let line = 1;
  let column = 1;
  let cur_c;
  // Holds a FIFO with the currenty ongoing arguments.
  // We must maintain this to know which argument is literal or not.
  let macro_argument_stack = [];
  // We are just after a previous argument, or just after the macro name.
  // Therefore the next char could be the start of a new argument.
  let last_possible_new_argument_index;
  let failed = false;

  const error = function(message) {
    report_error(line, column, message);
    failed = true;
  }

  const assert_could_be_argument = function() {
    if (i !== last_possible_new_argument_index) {
      error('cannot start a macro argument here. It has to come after a macro name or another macro argument.');
    }
  }

  // Advance the current character and set cur_c to the next one.
  //
  // Maintain the newline count up to date for debug messages.
  //
  // The current index must only be incremented through this function
  // and never directly.
  const consume = function() {
    if (chars[i] === '\n') {
      line += 1;
      column = 1;
    } else {
      column += 1;
    }
    i += 1;
    if (i >= chars.length) {
      return false;
    }
    cur_c = chars[i];
    return true;
  }

  const consume_optional_newline = function() {
    if (cur_c === '\n') {
      consume();
    }
  }

  const push_token = function(token, value) {
    tokens.push(new Token(token, line, column, value));
  }

  const tokenize_plaintext = function(tokens, c) {
    let last_token = tokens[tokens.length - 1];
    if (last_token.type === TokenType.PLAINTEXT) {
      last_token.value += c;
    } else {
      push_token(TokenType.PLAINTEXT, c);
    }
  }

  push_token(TokenType.MACRO_NAME, 'toplevel');
  push_token(TokenType.POSITIONAL_ARGUMENT_START);
  push_token(TokenType.MACRO_NAME, 'p');
  push_token(TokenType.POSITIONAL_ARGUMENT_START);
  while (consume()) {
    if (cur_c === '\\') {
      next_c = chars[i + 1];
      if (ESCAPABLE_CHARS.has(next_c)) {
        tokenize_plaintext(tokens, next_c);
        consume();
      } else {
        let macro_name = '';
        consume();
        while (char_is_macro(cur_c)) {
          macro_name += cur_c;
          consume();
        }
        consume_optional_newline();
        last_possible_new_argument_index = i;
        push_token(TokenType.MACRO_NAME, macro_name);
        macro_argument_stack.push([macros[macro_name], 0]);
      }
    } else if (cur_c === START_NAMED_ARGUMENT_CHAR) {
      assert_could_be_argument();
      consume_optional_newline();
    } else if (cur_c === END_NAMED_ARGUMENT_CHAR) {
      consume_optional_newline();
      last_possible_new_argument_index = i;
    } else if (cur_c === START_POSITIONAL_ARGUMENT_CHAR) {
      consume_optional_newline();
      push_token(TokenType.POSITIONAL_ARGUMENT_START);
    } else if (cur_c === END_POSITIONAL_ARGUMENT_CHAR) {
      consume_optional_newline();
      last_possible_new_argument_index = i;
      push_token(TokenType.POSITIONAL_ARGUMENT_END);
    } else if (cur_c === '\n') {
      if (((i + 1) === chars.length)) {
        // Do nothing.
      } else if (chars[i + 1] === '\n') {
        // Double newline.
        push_token(TokenType.POSITIONAL_ARGUMENT_END);
        push_token(TokenType.MACRO_NAME, 'p');
        push_token(TokenType.POSITIONAL_ARGUMENT_START);
        consume();
        done = true;
      } else {
        tokenize_plaintext(tokens, cur_c);
      }
    } else {
      tokenize_plaintext(tokens, cur_c);
    }
  }
  push_token(TokenType.POSITIONAL_ARGUMENT_END);
  push_token(TokenType.POSITIONAL_ARGUMENT_END);
  extra_returns.failed = true;
  return tokens;
}

const parse = function(tokens, options, extra_returns={}) {
  extra_returns.fail = false;
  let state = {
    i: -1,
    cur_token: undefined,
    options: options,
    extra_returns: extra_returns
  }
  return parse_macro(tokens, state)
}

const parse_macro = function(tokens, state) {
  const log_parse_debug = function(state, msg='') {
    if (state.options.show_parse) {
      console.log(msg);
    }
  }

  log_parse_debug(state, 'function: parse_macro')
  log_parse_debug(state, 'state.i = ' + state.i.toString())
  log_parse_debug(state)

  const consume = function() {
    state.i += 1;
    if (state.i >= tokens.length)
      return undefined;
    cur_token = tokens[state.i];
    log_parse_debug(state, 'function: consume');
    log_parse_debug(state, 'state.i = ' + state.i.toString())
    log_parse_debug(state, 'state.cur_token = ' + cur_token.toString());
    log_parse_debug(state);
    state.cur_token = cur_token;
    return cur_token;
  }

  const previous = function() {
    i = state.i - i;
    if (i < 0)
      return undefined;
    return tokens[i];
  }

  const report_parse_error = function(state, msg) {
    state.fail = true
    report_error(
      cur_token.line,
      cur_token.column,
      msg
    );
  }

  while (consume() !== undefined) {
    if (cur_token.type === TokenType.MACRO_NAME) {
      let macro_name = cur_token.value;
      let macro_line = cur_token.line;
      let macro_column = cur_token.column;
      let macro = macros[macro_name];
      let arg_count = 0;
      let args = {};
      consume();
      while (
        cur_token.type === TokenType.POSITIONAL_ARGUMENT_START ||
        cur_token.type === TokenType.NAMED_ARGUMENT_START
      ) {
        let arg;
        if (cur_token.type === TokenType.POSITIONAL_ARGUMENT_START) {
          arg = macro.index_to_arg[arg_count];
        } else {
          //arg = macro.index_to_arg[consume()];
        }
        let open_type = cur_token.type;
        let arg_children = [];
        while (
          cur_token.type !== TokenType.POSITIONAL_ARGUMENT_END &&
          cur_token.type !== TokenType.NAMED_ARGUMENT_END
        ) {
          log_parse_debug(state, 'case: argument');
          log_parse_debug(state, cur_token.type);
          log_parse_debug(state);
          arg_children.push(parse_macro(tokens, state));
        }
        if (cur_token.type !== closing_token(open_type)) {
          report_parse_error(
            state,
            `expected a closing ${END_POSITIONAL_ARGUMENT_CHAR} found ${cur_token.type.toString()}`
          );
        }
        args[arg.name] = arg_children;
        arg_count += 1;
      }
      return new AstNode(macro_name, args, macro_line, macro_column);
      macro_node = {
        type: token.value,
        children: children
      }
    } else if (cur_token.type === TokenType.PLAINTEXT) {
      let plaintext_node = new AstNode(
        'plaintext',
        cur_token.value,
        cur_token.line,
        cur_token.column
      );
      // Non-recursive case.
      consume();
      return plaintext_node;
    } else {
      report_parse_error(
        state,
        `unexpected token ${cur_token.type.toString()}`
      );
      return new AstNode(
        'plaintext',
        IN_OUTPUT_ERROR_PREFIX + 'unexpected token',
        cur_token.line,
        cur_token.column
      );
    }
    state.i += 1;
  }
}

/**
 * Main cirodown input to HTML/LaTeX/etc. output API wrapper.
 *
 * @returns {String}
 */
const convert = function(
  input_string,
  options,
  extra_returns={},
) {
  if (options === undefined) {
    options = {};
  }
  if (!'body_only'     in options) { options.body_only   = false; }
  if (!'show_ast'      in options) { options.show_ast    = false; }
  if (!'show_input'    in options) { options.show_input  = false; }
  if (!'show_output'   in options) { options.show_output = false; }
  if (!'show_parse'    in options) { options.show_parse  = false; }
  if (!'show_tokens'   in options) { options.show_tokens = false; }
  if (options.show_input) {
    console.log('input:')
    console.log(util.inspect(input_string));
    console.log();
  }
  let sub_extra_returns = {
    fail: false,
  };
  let tokens = tokenize(input_string, extra_returns);
  if (options.show_tokens) {
    console.log('tokens:');
    console.log(JSON.stringify(tokens, null, 2));
    console.log();
  }
  if (sub_extra_returns.fail) {
    extra_returns.fail = true;
  }
  sub_extra_returns = {
    fail: false,
  };
  let ast = parse(tokens, options, sub_extra_returns);
  if (sub_extra_returns.fail) {
    extra_returns.fail = true;
  }
  if (options.show_ast) {
    console.log('ast:');
    console.log(JSON.stringify(ast, null, 2));
    console.log();
  }
  let output = ast.convert(options);
  if (options.show_output) {
    console.log('output: ');
    console.log(util.inspect(output));
    console.log();
  }
  return output;
}

exports.convert = convert;

if (require.main === module) {
  let input;
  const encoding = 'utf8';
  let title;
  if (process.argv.length > 2) {
    title = process.argv[2]
    input = fs.readFileSync(title, encoding);
  } else {
    title = 'stdin'
    input = fs.readFileSync(0, encoding);
  }
  let extra_returns = {};
  console.log(convert(
    input,
    {
      body_only: true,
      title: title,
      show_ast: true,
      show_input: true,
      show_output: true,
      show_parse: true,
      show_tokens: true,
    },
    extra_returns
  ));
  process.exit(!extra_returns.fail);
}
